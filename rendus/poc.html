<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>POC</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="station-météo">Station Météo</h1>
<!-- Rapport du projet -->
<blockquote>
<p><strong>Auteurs :</strong> IRHBOULA Othmane, SALEK Adam, BURET Antoine et BEUNIER Gaspard</p>
</blockquote>
<p>La <strong>Station Météo</strong> est un projet ayant pour but de <strong>créer une station météo connectée</strong>. Ce projet, réalisé dans le contexte du module électif <em>“Projet Objet Connecté”</em>, a été <strong>entièrement réalisé par notre super équipe de 4</strong>.</p>
<p>Pour accompagner notre station météo, nous avons créé <strong>un Hub</strong>, hébergé en local avec un serveur Python qui s’occupe de <strong>récupérer les données</strong> et de les stocker sous forme d’historique dans une <strong>base de données</strong> mais aussi de rendre accessible un <strong>Dashboard</strong> sous forme de site web, <strong>mis à jour dynamiquement</strong> avec les dernières données, ainsi que la simulation de la maison en direct selon les données. La station météo <strong>envoie donc constamment les données</strong> qu’elle récupère au Hub et possède même <strong>son propre écran</strong> pour visualiser ces même données.</p>
<p><img src="https://i.imgur.com/dbVfFF7.png" alt="Screenshot d'un test non abouti du Dashboard"></p>
<h2 id="cahier-des-charges">Cahier des charges</h2>
<p>Pour ce projet, la première chose à faire était évidemment d’<strong>analyser le cahier des charges</strong> qui nous avait été confié. Nous pouvons alors le séparer en plusieurs tâches que nous listerons ci-dessous. Pour chacune d’elle, nous pouvons alors indiquer si nous avons réussi à l’implémenter ou non.</p>
<ul>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> <strong>Utiliser une Arduino Mega</strong> autour de laquelle on construirait la station météo.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Utiliser les données d’un <strong>capteur de température</strong> et les convertir en degré.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Utiliser les données d’un <strong>capteur d’humidité</strong> et les convertir en pourcentage.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Utiliser les données d’un <strong>capteur de luminosité</strong> et les convertir en pourcentage.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Utiliser les données d’un <strong>anémomètre</strong> et les convertir en kilomètre par heure.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Avoir <strong>des volets ouvrable et fermable</strong> avec un bouton.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Avoir <strong>des stores ouvrable et fermable</strong> avec un bouton.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> <strong>Afficher les données sur l’écran LCD</strong> connecté à l’Arduino.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Pouvoir <strong>contrôler l’affichage de l’écran avec des mouvement de la main</strong>.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> <strong>Stocker l’historique des données</strong> sur une base de données.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Avoir une <strong>simulation de maison à distance</strong> dépendante des conditions météorologiques mesurée.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled=""> Avoir un <strong>affichage des données à distance</strong>.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> Pouvoir <strong>ouvrir et fermer les volets à distance</strong>.</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> Pouvoir <strong>ouvrir et fermer les stores à distance</strong>.</li>
</ul>
<h2 id="comment-ça-marche-">Comment ça marche ?</h2>
<p>Pour ce projet, nous voulions faire <strong>comme les vrais objets connectés</strong>, c’est à dire avoir un <strong>système de Hub central</strong> qui <strong>gère et stocke les informations</strong> venant des différents objets, le seul étant ici <strong>la station météo</strong>. C’était totalement <strong>compatible avec le cahier des charges</strong> donné on a donc décidé de tout construire autour d’un petit <strong>serveur web en Python</strong>. Pour la communication entre l’Arduino de la station météo et le serveur du Hub, nous devions donc utiliser des <strong>requêtes HTTP</strong>. Notre but était aussi d’avoir un <strong>joli Dashboard sous la forme d’une page web</strong> accessible en local et sur laquelle seraient <strong>affichées toutes les informations disponibles et actualisées en temps réel</strong> ainsi que la simulation d’une maison qui évolue selon les conditions météorologiques actuelles.</p>
<blockquote>
<p>Le projet est disponible sur <a href="https://github.com/1m0ut0n/weather-station/tree/creation-db">GitHub</a> si vous souhaitez y jeter un coup d’œil</p>
</blockquote>
<p>Le <strong>principe de fonctionnement</strong> de l’ensemble du système est assez simple :</p>
<ol>
<li><strong>Les capteurs</strong> de la station météo vont réaliser une <em>mesure des conditions météorologique</em>.</li>
<li><strong>L’Arduino</strong> va récupérer ces <em>informations</em>.</li>
<li><strong>L’écran LCD</strong> de la station affichera alors les <em>données récoltées</em>.</li>
<li><strong>L’utilisateur</strong> peut alors naviguer parmi ces dernière grâce à des <em>gestes de la main</em>.</li>
<li><strong>L’Arduino</strong> enverra les <em>données récoltées</em> au Hub.</li>
<li><strong>Le serveur</strong> du Hub va récupérer les <em>informations</em> et les stocker dans une <strong>base de donnée</strong>.</li>
<li><strong>Le JavaScript</strong> du Dashboard demande alors <em>les dernières données</em> au Hub.</li>
<li><strong>Le serveur</strong> du Hub interroge alors sa <strong>base de donnée</strong> et donne les <em>dernières information</em> au <strong>JavaScript</strong>.</li>
<li><strong>Le JavaScript</strong> du Dashboard mets donc à jour <em>les données</em> sur <strong>la page web</strong>.</li>
</ol>
<pre class=" language-mermaid"><svg id="mermaid-svg-tWj7wjk3OF2MWzCh" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="486.3125" style="max-width: 1485.637939453125px;" viewBox="0 0 1485.637939453125 486.3125"><style>#mermaid-svg-tWj7wjk3OF2MWzCh{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#000000;}#mermaid-svg-tWj7wjk3OF2MWzCh .error-icon{fill:#552222;}#mermaid-svg-tWj7wjk3OF2MWzCh .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-tWj7wjk3OF2MWzCh .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-tWj7wjk3OF2MWzCh .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-tWj7wjk3OF2MWzCh .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-tWj7wjk3OF2MWzCh .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-tWj7wjk3OF2MWzCh .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-tWj7wjk3OF2MWzCh .marker{fill:#666;stroke:#666;}#mermaid-svg-tWj7wjk3OF2MWzCh .marker.cross{stroke:#666;}#mermaid-svg-tWj7wjk3OF2MWzCh svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-tWj7wjk3OF2MWzCh .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#000000;}#mermaid-svg-tWj7wjk3OF2MWzCh .cluster-label text{fill:#333;}#mermaid-svg-tWj7wjk3OF2MWzCh .cluster-label span{color:#333;}#mermaid-svg-tWj7wjk3OF2MWzCh .label text,#mermaid-svg-tWj7wjk3OF2MWzCh span{fill:#000000;color:#000000;}#mermaid-svg-tWj7wjk3OF2MWzCh .node rect,#mermaid-svg-tWj7wjk3OF2MWzCh .node circle,#mermaid-svg-tWj7wjk3OF2MWzCh .node ellipse,#mermaid-svg-tWj7wjk3OF2MWzCh .node polygon,#mermaid-svg-tWj7wjk3OF2MWzCh .node path{fill:#eee;stroke:#999;stroke-width:1px;}#mermaid-svg-tWj7wjk3OF2MWzCh .node .label{text-align:center;}#mermaid-svg-tWj7wjk3OF2MWzCh .node.clickable{cursor:pointer;}#mermaid-svg-tWj7wjk3OF2MWzCh .arrowheadPath{fill:#333333;}#mermaid-svg-tWj7wjk3OF2MWzCh .edgePath .path{stroke:#666;stroke-width:1.5px;}#mermaid-svg-tWj7wjk3OF2MWzCh .flowchart-link{stroke:#666;fill:none;}#mermaid-svg-tWj7wjk3OF2MWzCh .edgeLabel{background-color:white;text-align:center;}#mermaid-svg-tWj7wjk3OF2MWzCh .edgeLabel rect{opacity:0.5;background-color:white;fill:white;}#mermaid-svg-tWj7wjk3OF2MWzCh .cluster rect{fill:hsl(210,66.6666666667%,95%);stroke:#26a;stroke-width:1px;}#mermaid-svg-tWj7wjk3OF2MWzCh .cluster text{fill:#333;}#mermaid-svg-tWj7wjk3OF2MWzCh .cluster span{color:#333;}#mermaid-svg-tWj7wjk3OF2MWzCh div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(-160,0%,93.3333333333%);border:1px solid #26a;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-tWj7wjk3OF2MWzCh:root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-svg-tWj7wjk3OF2MWzCh flowchart-v2{fill:apa;}</style><g transform="translate(0, 0)"><marker id="flowchart-pointEnd" class="marker flowchart" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="userSpaceOnUse" markerWidth="12" markerHeight="12" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="flowchart-pointStart" class="marker flowchart" viewBox="0 0 10 10" refX="0" refY="5" markerUnits="userSpaceOnUse" markerWidth="12" markerHeight="12" orient="auto"><path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="flowchart-circleEnd" class="marker flowchart" viewBox="0 0 10 10" refX="11" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle></marker><marker id="flowchart-circleStart" class="marker flowchart" viewBox="0 0 10 10" refX="-1" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle></marker><marker id="flowchart-crossEnd" class="marker cross flowchart" viewBox="0 0 11 11" refX="12" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><marker id="flowchart-crossStart" class="marker cross flowchart" viewBox="0 0 11 11" refX="-1" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><g class="root"><g class="clusters"><g class="cluster default" id="station"><rect style="" rx="0" ry="0" x="8" y="8" width="756.9661560058594" height="135.9375"></rect><g class="cluster-label" transform="translate(336.86328506469727, 13)"><foreignObject width="99.23958587646484" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Station Météo</span></div></foreignObject></g></g><g class="cluster default" id="hub"><rect style="" rx="0" ry="0" x="581.3177185058594" y="163.9375" width="646.8281402587891" height="182.65625"></rect><g class="cluster-label" transform="translate(890.6692886352539, 168.9375)"><foreignObject width="28.125" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Hub</span></div></foreignObject></g></g><g class="cluster default" id="dash"><rect style="" rx="0" ry="0" x="1040.3307495117188" y="366.59375" width="437.3072967529297" height="111.71875"></rect><g class="cluster-label" transform="translate(1221.7448120117188, 371.59375)"><foreignObject width="74.47917175292969" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Dashboard</span></div></foreignObject></g></g></g><g class="edgePaths"><path d="M1183.9218978881836,422.453125L1191.292558034261,422.453125C1198.6632181803386,422.453125,1213.4045384724934,422.453125,1231.6389141082764,422.453125C1249.8732897440593,422.453125,1271.60072072347,422.453125,1293.3281517028809,422.453125C1315.0555826822917,422.453125,1336.7830136617024,422.453125,1347.646729151408,422.453125L1358.5104446411133,422.453125" id="L-js-html" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-js LE-html" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M1077.639394239163,252.765625L1071.421286784589,255.05729166666666C1065.203179330015,257.3489583333333,1052.766964420867,261.9322916666667,1023.6018075074712,264.2239583333333C994.4366505940756,266.515625,948.5425516764323,266.515625,902.6484527587891,266.515625C856.7543538411459,266.515625,810.8602549235026,266.515625,783.7465387980143,266.515625C756.632822672526,266.515625,748.2994893391927,266.515625,744.132822672526,266.515625L739.9661560058594,266.515625" id="L-db-serveur" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-db LE-serveur" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M714.1403760622975,245.65625L722.6113393862246,241.34635416666666C731.0823027101515,237.03645833333334,748.0242293580054,228.41666666666666,779.442242140754,224.10677083333334C810.8602549235026,219.796875,856.7543538411459,219.796875,902.6484527587891,219.796875C948.5425516764323,219.796875,994.4366505940756,219.796875,1021.5503667195638,220.33416648168497C1048.664082845052,220.87145796336995,1056.9974161783855,221.94604092673993,1061.164082845052,222.4833324084249L1065.3307495117188,223.0206238901099" id="L-serveur-db" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-serveur LE-db" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M714.1403760622975,287.375L722.6113393862246,291.6848958333333C731.0823027101515,295.9947916666667,748.0242293580054,304.6145833333333,779.442242140754,308.9244791666667C810.8602549235026,313.234375,856.7543538411459,313.234375,902.6484527587891,313.234375C948.5425516764323,313.234375,994.4366505940756,313.234375,1030.045770186723,327.9609375C1065.6548897793707,342.6875,1090.9790300470224,372.140625,1103.6411001808483,386.8671875L1116.3031703146742,401.59375" id="L-serveur-js" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-serveur LE-js" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M359.6822967529297,85.2015543871011L378.1519152323405,89.43098282258426C396.6215337117513,93.66041125806741,433.56077067057294,102.1192681290337,470.50000762939453,106.34869656451684C507.4392445882161,110.578125,544.3784815470377,110.578125,576.1049532511271,133.09114583333334C607.8314249552164,155.60416666666666,634.3451314045734,200.63020833333334,647.601984629252,223.14322916666666L660.8588378539305,245.65625" id="L-arduino-serveur" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-arduino LE-serveur" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M121.8359375,75.96875L134.93663215637207,75.96875C148.03732681274414,75.96875,174.23871612548828,75.96875,200.44010543823242,75.96875C226.64149475097656,75.96875,252.8428840637207,75.96875,265.9435787200928,75.96875L279.04427337646484,75.96875" id="L-capteur-arduino" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-capteur LE-arduino" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path><path d="M359.6822967529297,72.7383105417592L378.1519152323405,71.25848795146601C396.6215337117513,69.7786653611728,433.56077067057294,66.8190201805864,470.50000762939453,65.33919759029321C507.4392445882161,63.859375,544.3784815470377,63.859375,570.0191071828207,63.859375C595.6597328186035,63.859375,610.0017471313477,63.859375,617.1727542877197,63.859375L624.3437614440918,63.859375" id="L-arduino-ecran" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-arduino LE-ecran" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path></g><g class="edgeLabels"><g class="edgeLabel" transform="translate(1293.3281517028809, 422.453125)"><g class="label" transform="translate(-40.18229293823242, -13.359375)"><foreignObject width="80.36458587646484" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Mets à jour</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(902.6484527587891, 266.515625)"><g class="label" transform="translate(-112.68229675292969, -13.359375)"><foreignObject width="225.36459350585938" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Retourne les dernières données</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(902.6484527587891, 219.796875)"><g class="label" transform="translate(-102.97917175292969, -13.359375)"><foreignObject width="205.95834350585938" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Enregistre données actuelles</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(902.6484527587891, 313.234375)"><g class="label" transform="translate(-99.453125, -13.359375)"><foreignObject width="198.90625" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Envoi les dernières données</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(470.50000762939453, 110.578125)"><g class="label" transform="translate(-85.81771087646484, -13.359375)"><foreignObject width="171.6354217529297" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Envoi données actuelles</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(200.44010543823242, 75.96875)"><g class="label" transform="translate(-53.60416793823242, -13.359375)"><foreignObject width="107.20833587646484" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Mesures météo</span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(470.50000762939453, 63.859375)"><g class="label" transform="translate(-69.71875, -13.359375)"><foreignObject width="139.4375" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel">Affiche les mesures</span></div></foreignObject></g></g></g><g class="nodes"><g class="node default default" id="flowchart-arduino-370" transform="translate(319.36328506469727, 75.96875)"><rect style="" rx="20.859375" ry="20.859375" x="-40.31901168823242" y="-20.859375" width="80.63802337646484" height="41.71875"></rect><g class="label" style="" transform="translate(-27.604167938232422, -13.359375)"><foreignObject width="55.208335876464844" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Arduino</span></div></foreignObject></g></g><g class="node default default" id="flowchart-capteur-371" transform="translate(77.41796875, 75.96875)"><rect style="" rx="20.859375" ry="20.859375" x="-44.41796875" y="-20.859375" width="88.8359375" height="41.71875"></rect><g class="label" style="" transform="translate(-31.703125, -13.359375)"><foreignObject width="63.40625" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Capteurs</span></div></foreignObject></g></g><g class="node default default" id="flowchart-ecran-373" transform="translate(673.1419372558594, 63.859375)"><rect style="" rx="20.859375" ry="20.859375" x="-48.798179626464844" y="-20.859375" width="97.59635925292969" height="41.71875"></rect><g class="label" style="" transform="translate(-36.083335876464844, -13.359375)"><foreignObject width="72.16667175292969" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Ecran LCD</span></div></foreignObject></g></g><g class="node default default" id="flowchart-serveur-368" transform="translate(673.1419372558594, 266.515625)"><rect style="" rx="20.859375" ry="20.859375" x="-66.82421875" y="-20.859375" width="133.6484375" height="41.71875"></rect><g class="label" style="" transform="translate(-54.109375, -13.359375)"><foreignObject width="108.21875" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Serveur Python</span></div></foreignObject></g></g><g class="node default default" id="flowchart-db-369" transform="translate(1134.2383041381836, 231.90625)"><rect style="" rx="20.859375" ry="20.859375" x="-68.90755462646484" y="-20.859375" width="137.8151092529297" height="41.71875"></rect><g class="label" style="" transform="translate(-56.192710876464844, -13.359375)"><foreignObject width="112.38542175292969" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Base de donnée</span></div></foreignObject></g></g><g class="node default default" id="flowchart-html-372" transform="translate(1405.5742454528809, 422.453125)"><rect style="" rx="20.859375" ry="20.859375" x="-47.063804626464844" y="-20.859375" width="94.12760925292969" height="41.71875"></rect><g class="label" style="" transform="translate(-34.348960876464844, -13.359375)"><foreignObject width="68.69792175292969" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">Page Web</span></div></foreignObject></g></g><g class="node default default" id="flowchart-js-366" transform="translate(1134.2383041381836, 422.453125)"><rect style="" rx="20.859375" ry="20.859375" x="-49.68359375" y="-20.859375" width="99.3671875" height="41.71875"></rect><g class="label" style="" transform="translate(-36.96875, -13.359375)"><foreignObject width="73.9375" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="nodeLabel">JavaScript</span></div></foreignObject></g></g></g></g></g></svg></pre>
<p>Afin de mieux comprendre, nous reviendrons <strong>plus en détail sur la manière dont nous les avons mises en place</strong> dans les paragraphes suivant. Ainsi, nous <strong>expliquerons le fonctionnement</strong> des différentes analyses, de l’évaluateur mais aussi de l’affichage dynamique de la courbe. Nous parlerons aussi du Dashboard, du serveur et de sa base de données, notamment comment ils <strong>communiquent entre eux</strong>. Enfin, nous finirons par détailler <strong>la communication entre la station et le serveur</strong>.</p>
<h3 id="mesures-par-capteurs">Mesures par capteurs</h3>
<blockquote>
<p>Par <em>SALEK Adam</em></p>
</blockquote>
<p>Dans le fichier <code>weather-station</code> du <a href="https://github.com/1m0ut0n/weather-station/tree/creation-db">GitHub du projet</a> se trouve le <strong>code l’Arduino</strong>. C’est lui qui réalise <strong>les mesures par capteurs</strong>, l’<strong>affichage des données récoltées en temps réels sur son écran</strong> et l’<strong>envoi de ces mêmes données au serveur</strong>.</p>
<p>Au total, nous avons 3 capteurs branchés sur la carte Arduino Mega, pour récuperer les données de chacune nous procédons de la manière suivante :</p>
<ul>
<li><strong>Anémomètre (Capteur de Vent) :</strong> Pour l’anémomètre, on a branché un pin sur le port Digital 3 et le second à la Terre <em>(Gnd)</em>. On l’initialise en <code>INPUT_PULLUP</code> avec la fonction <code>pinMode()</code>. Pour repérer le moment où l’anémomètre fait un tour sur lui même, on regarde le moment où la valeur de sortie change d’état <em>(0 ou 1)</em>. On compte ensuite le nombre de tours, donc de changements d’état, enregistrés en 1000 millisecondes à l’aide de la fonction <code>millis()</code>, on multiplie ensuite ce résultat par la constante <code>windFactor</code> <em>(ici égale à 1.77)</em> donnée par la datasheet de l’anémomètre. Ce résultat équivaut alors à la vitesse du vent en <em>km/h</em>, et est stocké dans la variable <code>windSpeed</code>.</li>
<li><strong>Capteur de Luminosité :</strong> Pour le capteur de luminosité, on branche le capteur sur le port Analogique A1 et on récupère ses données avec la fonction <code>analogRead()</code> affectée au port A1. Cette valeur est ensuite divisée par 195.0 <em>(approche empirique : valeur maximale atteinte par le capteur lorsque l’on place un flash devant)</em> puis multipliée par 100 afin de donner un pourcentage. Ce résultat est stocké dans la variable <em>light</em>.</li>
<li><strong>Capteur de Température et d’Humidité :</strong> On utilise, pour le capteur de Température et d’Humidité, la bibliothèque DHT, plus précisément ici affectée aux capteur de type DHT22, ce capteur est branché sur le porte Digital 2. Grâce à cette bibliothèque, il suffit d’utiliser les fonctions <code>dht.readHumidity()</code> et <code>dht.readTemperature()</code> pour lire les valeurs d’humidité en pourcentage, et de température en degrés Celsius. Ces valeurs sont stockées dans les variables <code>humidity</code> et <code>temperature</code>.</li>
</ul>
<h3 id="affichage-ecran-lcd-et-commandes">Affichage Ecran LCD et commandes</h3>
<blockquote>
<p>Par <em>IRHBOULA Othmane</em></p>
</blockquote>
<p>La station météo possède <strong>son propre écran</strong> ainsi qu’un <strong>capteur de mouvement</strong>. L’idée et alors d’utiliser les deux pour <strong>afficher en temps réel les données</strong> récoltées par les capteurs tout en <strong>naviguant grâce à des gestes</strong> de la main.</p>
<p>Tout d’abord, il est nécessaire d’<strong>importer les bibliothèques nécessaires</strong>, notamment <code>Wire.h</code> pour la <strong>communication I2C</strong>, <code>paj7620.h</code> pour la <strong>communication avec le capteur de mouvement</strong> et <code>LiquidCrystal.h</code> pour le <strong>contrôle de l’écran LCD</strong>. Ensuite, nous <strong>définissons les broches</strong> utilisées pour le contrôle de l’écran LCD. Dans la fonction <code>setup()</code>, nous <strong>initialisons l’écran LCD</strong> en utilisant la méthode <code>begin(16, 2)</code> pour spécifier la taille de l’affichage dans notre cas 16 colonnes 2 lignes. Ensuite, nous appelons la fonction <code>paj7620Init()</code> pour <strong>initialiser le capteur de mouvement</strong>. Dans la boucle <code>loop()</code>, nous déclarons une variable <code>data</code> qui sera utilisée pour <strong>stocker les résultats de détection de geste</strong>s du capteur de mouvement. Ensuite, à l’aide de la fonction <code>paj7620ReadReg(0x43, 1, &amp;data)</code> la variable data sera <strong>mise à jour en fonction du mouvement détecté</strong>.</p>
<p>Pour pouvoir se déplacer dans les menus, nous utilisons des <strong>instructions conditionnelles</strong> pour vérifier la valeur de <code>data</code> et <strong>effectuer différentes actions en fonction du geste détecté</strong>. Par exemple, si <code>data</code> correspond à <code>GES_RIGHT_FLAG</code> <em>(mouvement à droite)</em>, nous effaçons l’écran LCD à l’aide de la méthode <code>clear()</code> et affichons le menu suivant, et on suit un raisonnement analogue pour les mouvements <code>GES_LEFT_FLAG</code>, <code>GES_UP_FLAG</code> et <code>GES_DOWN_FLAG</code> correspondant respectivement à des mouvements à gauche, en haut et en bas.</p>
<h3 id="serveur-et-base-de-données-backend">Serveur et Base de Données (Backend)</h3>
<blockquote>
<p>Par <em>BEUNIER Gaspard</em></p>
</blockquote>
<p>Le serveur est réalisé avec un <strong>framework open-source appelé</strong> <a href="https://flask.palletsprojects.com/"><strong>Flask</strong></a>. Nous avons décidé d’utilisé ce framework web car nous savions déjà comment l’utiliser, qu’il est <strong>simple</strong>, <strong>léger</strong>, <strong>pratique</strong> mais aussi car il en existe une extension appelée <a href="https://flask-sqlalchemy.palletsprojects.com/"><em>Flask-SQLAlchemy</em></a> faite pour pouvoir facilement utiliser <a href="https://www.sqlalchemy.org/"><em>SQLAlchemy</em></a> avec notre serveur. Cela nous permet de <strong>facilement créer, gérer et questionner des base de donnée</strong> directement en Python.</p>
<p>Même si <em>Flask</em> permet de créer un serveur en un seul fichier, nous avons <strong>séparé le notre en plusieurs</strong> afin de <strong>s’y retrouver plus aisément</strong>. Dans le fichier <code>server</code> du <a href="https://github.com/1m0ut0n/weather-station/tree/creation-db">GitHub du projet</a> vous trouverez par exemple :</p>
<ul>
<li>Un script que l’on <strong>exécute</strong> est <code>run.py</code>. Il va en fait <strong>exécuter les fichiers d’initialisation</strong> de ce que l’on appelle ici <em>“l’application”</em> puis <strong>ouvrir l’application</strong> à l’ensemble du réseau local.</li>
<li>C’est le script <code>app/__init__.py</code> qui <strong>initialise notre application</strong>. Il va importer <em>Flask</em> et <em>Flask-SQLAlchemy</em> puis réaliser l’initialisation de la base de donnée et du serveur. Il va ensuite importer les fichiers qui définissent ces deux derniers.</li>
<li>Le script <code>app/views.py</code> <strong>définit les différentes routes web</strong>.</li>
<li>Le script <code>app/models.py</code> <strong>définit la base donnée</strong> et <strong>la créée</strong>.</li>
</ul>
<p>Plusieurs routes sont mises en place, chacune ayant des buts différents :</p>
<ul>
<li>Le Dashboard est directement accessible depuis la <strong>route initiale</strong> <code>/</code> avec <strong>n’importe quel navigateur</strong>. Elle n’est donc utilisable qu’avec une méthode <code>GET</code> qui renvoie donc le HTML de la page après qu’il ait été <strong>rendu par le server</strong>.</li>
<li>Pour <strong>mettre à jour les données de la page web</strong>, son script JavaScript va faire des <strong>requêtes</strong> <code>GET</code> sur la route <code>/maj</code> auxquelles le serveur répondra avec un fichier <em>json</em> en deux parties : la première avec <strong>l’ensemble des données et état actuels</strong> ainsi que la date de cette donnée et la seconde un tableau des <strong>50 dernières données</strong> de température, humidité, lumière et vent.</li>
<li>Lorsque l’Arduino a de <strong>nouvelles données à envoyer</strong> il fait une <strong>requête</strong> <code>POST</code> au serveur avec les données sous forme de <em>json</em>. Le serveur peut alors les <strong>enregistrer dans la base de données</strong>.</li>
</ul>
<p>La <strong>base de donnée</strong> ne comporte qu’<strong>une seule table</strong> appelée <code>Data</code> qui stocke l’<strong>historique des données météorologiques</strong> sous cette forme :</p>

<table>
<thead>
<tr>
<th align="center">Attribut</th>
<th align="center">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><strong>id</strong></td>
<td align="center">int <em>(PRIMARY KEY)</em></td>
<td align="left">Identifiant unique de l’entrée</td>
</tr>
<tr>
<td align="center"><strong>date</strong></td>
<td align="center">datetime</td>
<td align="left">Date et horaire au moment de l’enregistrement</td>
</tr>
<tr>
<td align="center"><strong>temperature</strong></td>
<td align="center">float</td>
<td align="left">Temperature en <em>°C</em></td>
</tr>
<tr>
<td align="center"><strong>humidity</strong></td>
<td align="center">float</td>
<td align="left">Humidité en <em>%</em></td>
</tr>
<tr>
<td align="center"><strong>light</strong></td>
<td align="center">float</td>
<td align="left">Luminosité en <em>%</em></td>
</tr>
<tr>
<td align="center"><strong>wind</strong></td>
<td align="center">float</td>
<td align="left">Vitesse du vent en <em>km/h</em></td>
</tr>
<tr>
<td align="center"><strong>shutter</strong></td>
<td align="center">boolean</td>
<td align="left">Etat des volets <em>(Fermé/Ouvert)</em></td>
</tr>
<tr>
<td align="center"><strong>blind</strong></td>
<td align="center">boolean</td>
<td align="left">Etat des stores <em>(Fermé/Ouvert)</em></td>
</tr>
</tbody>
</table><h3 id="dashboard-web-frontend">Dashboard Web (Frontend)</h3>
<blockquote>
<p>Par <em>BEUNIER Gaspard</em></p>
</blockquote>
<p>Le <strong>Dashboard</strong> fut construit un peu à part <strong>vers la fin</strong> du projet. Le but était de pouvoir <strong>voir d’un coup d’œil chacune des données météo actuelles</strong> ainsi qu’un graphique des données précédentes, mais aussi d’avoir un espace ou afficher une <strong>simulation de la maison</strong> selon les conditions météorologiques actuelles. Tout devait être fait de telle sorte qu’il puisse être <strong>modifié dynamiquement</strong> par un script JavaScript communiquant avec le serveur en arrière plan.</p>
<p>Sur le <strong>Dashboard</strong> on trouve donc :</p>
<ul>
<li>La <strong>simulation de la maison</strong> qui s’adapte selon la météo.</li>
<li>Une <strong>carte pour chacune des données</strong> récupérées par la station en temps réel, c’est à dire la température, le taux d’humidité, la lumière et enfin la vitesse du vent. La carte comporte aussi un graphique retraçant <strong>l’évolution de la donnée dans le temps</strong>.</li>
<li>Une <strong>carte pour l’état des volets et stores</strong>. On y trouve aussi un <strong>bouton pour ouvrir ou fermer</strong> chacun d’entre eux.</li>
<li>Un bouton pour <strong>modifier l’IP de la station météo</strong> <em>(l’adresse IP est trouvable sur l’écran de cette dernière)</em>.</li>
<li>Le <strong>moment de la dernière actualisation</strong> de la page et des données.</li>
</ul>
<p>Les <strong>éléments les plus importants</strong> comme les données sont affichées en gros et la simulation de la maison prend une place importante. La page est ‘<em><strong>responsive</strong></em>’, c’est à dire qu’elle s’adapte selon la taille de l’écran, si l’écran rétrécit, les cartes se réorganiseront de manière à prendre moins de place. Pour le <strong>style de la page</strong>, on utilise en fait <a href="https://getbootstrap.com/"><em>Bootstrap</em></a> qui sont simplement des <strong>feuilles de styles déjà faites</strong>. Pour les <strong>graphiques</strong>, on utilise <a href="https://www.chartjs.org/"><em>Charts.js</em></a>, qui, de la même manière, est une <strong>bibliothèque JavaScript pour créer des graphiques</strong> plus facilement.</p>
<p>La page est trouvable sur le <a href="https://github.com/1m0ut0n/weather-station/tree/creation-db">GitHub du projet</a> sous la forme d’une <strong>template HTML</strong> avec une syntaxe de rendu <a href="https://jinja.palletsprojects.com/"><em>Jinja</em></a>. En fait, lorsque le serveur devra envoyer la page, il va <strong>réaliser un rendu</strong>, c’est à dire qu’il va regarder sur la page les endroits qui sont à modifier selon le contexte et donc modifier la page à chaque requête. Les images et scripts JavaScript écrit par nos soins stockées dans le dossiers <code>app/static</code> sont intégrés de cette manière. Les scripts JavaScript et feuilles de styles CSS sont elles intégrées via des <a href="https://www.cloudflare.com/fr-fr/learning/cdn/what-is-a-cdn/">CDN</a>.</p>
<h3 id="modification-dynamique-des-données">Modification dynamique des données</h3>
<blockquote>
<p>Par <em>BURET Antoine</em></p>
</blockquote>
<p>Afin d’<strong>afficher en temps réel</strong> les données sur la page Web, on a d’abord besoin de <strong>récupérer les données récoltées</strong> par la carte Arduino sur le serveur Python. Pour ce faire, <strong>toutes les secondes</strong> <em>(arbitraire)</em>, le microcontrôleur envoie sur le serveur les données récoltées grâce à une <strong>requête HTTP</strong>, puis le serveur va stocker ces nouvelles entrées dans la base de données. De l’autre côté du tableau, on va simplement faire une <strong>requête en Javascript sur le serveur</strong> afin de récupérer les données stockées toutes les secondes. Ce n’est donc <strong>pas une seule requête</strong> qui a lieu, mais bien <strong>deux</strong> qui ne <strong>s’exécutent pas simultanément</strong>, une d’envoi depuis la carte Arduino et une de réception depuis le site Web.</p>
<h3 id="simulation-de-la-maison">Simulation de la maison</h3>
<blockquote>
<p>Par <em>BURET Antoine</em></p>
</blockquote>
<p>Pour simuler l’<strong>affichage d’une maison et de la météo</strong> selon les conditions réelles, on va utiliser <em>Processing</em> et plus spécifiquement la bibliothèque <a href="https://p5js.org/"><em>p5</em></a> en Javascript. Cette bibliothèque permet de <strong>dessiner en boucle en Javascript</strong> et donc de <strong>faire des animations</strong>. Elle utilise deux fonctions principales :</p>
<ul>
<li>La fonction <code>setup()</code> qui est appelée <strong>une fois au démarrage du programme</strong>. Elle est utilisé pour <strong>définir les propriétés initiales</strong> de l’environnement telles que la taille de l’écran et la couleur d’arrière-plan et pour <strong>charger des médias</strong> tels que des images et des polices au démarrage du programme.</li>
<li>La fonction <code>draw()</code>, appelée directement après <code>setup()</code>, qui <strong>exécute en continu les lignes de code contenues dans son bloc</strong> jusqu’à ce que le programme soit arrêté ou que <code>noLoop()</code> soit appelée.</li>
</ul>
<p>Quand on veut dessiner, on commence donc par <strong>définir la couleur du ciel selon la luminosité observée</strong>, la <strong>quantité de nuages selon le même paramètre</strong>, la <strong>vitesse des nuages dépendante de la vitesse du vent</strong>. On crée également des classes Nuage, Goutte et Flocon qui vont permettre de traiter chaque élément comme des objets ayant des attributs de position, de vitesse ou encore de taille. Ensuite <strong>on affiche ces mêmes nuages</strong> en utilisant une fonction de <em>p5</em> se nommant <code>ellipse()</code> puis on les fait se déplacer à la vitesse attribuée de gauche à droite du canva contenant l’affichage de la maison. Pour <strong>afficher tous les autres éléments</strong> tels que la maison, le ciel, l’herbe, les barrières, la pluie ou la neige, on utilise les fonctions <code>point()</code>, <code>line()</code> et <code>rect()</code>. On affiche <strong>les volets et stores ouverts ou fermés selon les données récupérées</strong> et enfin, si les conditions sont remplies, on <strong>affiche de la pluie ou de la neige</strong>. Il faut un taux d’humidité supérieur à 90% pour qu’il y’ait de la pluie et pour la neige, il faut également que la température soit inférieure ou égale à 0.</p>
<h3 id="communication-arduino-→-serveur">Communication Arduino → Serveur</h3>
<blockquote>
<p>Par SALEK Adam et un peu tout le monde</p>
</blockquote>
<p>On savait que le fait de <strong>communiquer de l’Arduino au serveur</strong> serait <strong>la partie la plus complexe</strong> c’est pourquoi c’est en fait la chose que l’on a <strong>testée en premier</strong>, tout en sachant que ce serait l’une des <strong>dernière chose à implémenter</strong>. L’idée était d’envoyer les données sous forme de <strong>requêtes HTTP</strong> avec une méthode POST et d’y <strong>inclure donc les données</strong> en <em>json</em>. L’Arduino, pour se connecter au réseau local, utiliserai alors un <strong>shield Ethernet</strong> accompagné de la bibliothèque <code>Ethernet.h</code>. Et on a bien fait de tester ça dès le début car ça nous a pris presque trois cours pour avoir quelque chose de fonctionnel. On a rencontré quelques problèmes sur la route, d’abord du à la <strong>syntaxe très restrictive des requêtes HTTP</strong> mais aussi à cause des <strong>restrictions sur le réseau interne de l’IMT</strong>. Il nous a fallu au moins 5h de recherche et de <em>reverse-engineering</em> du réseau de l’école pour comprendre que la communication entre différents masques de sous réseau était bloquée en local. Après avoir réussi les tests, on a implémenté tout le reste puis on est revenu dessus à la fin avec l’implémentation suivante :</p>
<p>On souhaite maintenant <strong>envoyer les données collectées au serveur</strong>, ainsi que les <strong>états des volets et des stores</strong> de la maison. La variable que l’on souhaite envoyer doit être <strong>sous la forme d’un</strong> <em><strong>json</strong></em> que l’on construit dans notre code <em>Arduino</em> de la manière suivante :</p>
<pre class=" language-arduino"><code class="prism  language-arduino">queryString <span class="token operator">=</span> <span class="token string">"{\"temperature\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>temperature<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", \"humidity\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>humidity<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", \"light\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>light<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", \"wind\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>windSpeed<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", \"shutterstate\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>voletState<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", \"blindstate\":"</span><span class="token operator">+</span> <span class="token keyword">String</span><span class="token punctuation">(</span>storeState<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"}"</span>
</code></pre>
<p>On <strong>envoie ainsi les valeurs</strong> de température, d’humidité, de luminosité et de vent à travers 4 variables, ainsi que les états des stores et des volets. Ces valeurs sont ici toutes transformées en String pour pouvoir être mises sous la forme de données <em>json</em>. Pour <strong>envoyer ces données au serveur</strong>, on utilise la fonction <code>envoyerServ()</code> qui tente de se <strong>connecter à un serveur</strong> en utilisant la méthode <code>connect</code> de l’objet <code>client</code>. Le serveur auquel on se connecte est <strong>défini par les variables</strong> <code>HOST_NAME</code> et <code>HTTP_PORT</code>. Si la connexion réussit, on affiche le message <em>“Connecté au serveur”</em> sur le port série. Ensuite, la fonction <strong>envoie une requête HTTP au serveur</strong>. La requête est <strong>construite en utilisant différentes informations</strong> telles que <code>HTTP_METHOD</code>, <code>PATH_NAME</code>, <code>HOST_NAME</code>, <code>CONTENT_TYPE</code> et enfin <code>queryString</code> que <strong>l’on a construit plus tôt</strong> avec les variables des différents capteurs connectés à la carte Arduino. Toutes <strong>ces informations sont envoyées au serveur</strong> via l’objet <code>client</code> en utilisant la méthode <code>println</code>. Ensuite, la fonction <strong>attend une réponse du serveur</strong> en <strong>vérifiant si des données sont disponibles</strong> à l’aide de la méthode <code>available</code> de l’objet <code>client</code>. Si des données sont disponibles, elles sont <strong>lues caractère par caractère</strong> à l’aide de la méthode <code>read</code> de l’objet <code>client</code>. Les caractères lus sont ensuite ajoutés à la variable <code>retourServeur</code> et affichés sur le port série. Une fois la boucle terminée, la fonction recherche la position de la première occurrence du caractère <code>[</code> dans la chaîne <code>retourServeur</code> à l’aide de la méthode <code>indexOf</code>. Si elle trouve le caractère <code>[</code> dans la chaîne, elle extrait une sous-chaîne à partir de cette position jusqu’à la fin de la chaîne à l’aide de la méthode <code>substring</code>. Sinon, elle initialise <code>retourServeur</code> à une chaîne vide. La variable <code>retourServeur</code> nous aide à <strong>contrôler l’ouverture et la fermeture des volets et des stores à partir du serveur</strong>. Ensuite, la <strong>connexion au serveur est fermée</strong> à l’aide de la méthode <code>stop</code> de l’objet <code>client</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>On est <strong>assez déçus</strong> de ne <strong>pas avoir réussi à terminer le projet</strong> de la manière que nous le voulions alors qu’on était <strong>si proche du but</strong>. On peut peut-être en tirer quelques conclusions et pistes de réflexion quant aux erreurs qui ont pu nous amener à cette réussite partielle. Peut-être que <strong>nous avons voulu aller trop loin</strong> ou <strong>faire quelque chose de trop abouti</strong> par rapport à ce qui était nécessaire. Nous regrettons d’<strong>avoir perdu autant de temps sur des problèmes pour lesquels nous n’y étions pour rien</strong>, notamment celui à propos des restrictions du réseau de l’école. Mais nous somme tout de même <strong>assez fiers</strong> car <strong>le résultat est celui que nous imaginions</strong>. A part le fait de pouvoir ouvrir et fermer les volets à distance, une fonctionnalité qui était pourtant <strong>prête côté Arduino et côté Dashboard</strong> mais pour laquelle nous rencontrions des problèmes coté serveur, <strong>tout fonctionne à merveille</strong>, exactement comme nous l’imaginions. C’est <strong>joli</strong>, <strong>intuitif</strong>, <strong>facilement utilisable</strong>, <strong>les informations sont trouvables facilement</strong> et on a pu implémenter <strong>plein de petites fonctionnalités en plus</strong> qui <strong>améliorent la vie de l’utilisateur</strong> <em>(système de connexion Arduino Serveur, changement de couleur de l’écran LCD suivant le type d’information, graphiques retraçant l’historique, une vraie base de donnée SQLite3, …)</em>. On est <strong>globalement assez fiers</strong> de ce qui a été réalisé avec tout de même <strong>une déception</strong> sur le fait de ne pas avoir pu terminer en étant <strong>si proche du but</strong>.</p>
<p><strong>En tout cas, on s’est tous beaucoup amusé sur ce projet</strong>, c’est pourquoi on a toujours essayé de le pousser au maximum même si ce ne fut pas très concluant. <strong>Peut-être qu’on essayera de le terminer un jour</strong> étant donné qu’il ne reste vraiment pas grand chose !</p>
</div>
</body>

</html>
